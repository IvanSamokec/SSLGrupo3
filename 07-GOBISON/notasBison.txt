line: expr ';' { printf("El resultado de la expresión es: %d\n", $1); }
    ;

    // %x tokenNoReconocido

<tokenNoReconocido>{
    [ \t\n] {
        actualizarLocationsColumnas();
        BEGIN(INITIAL);
    }
    [^ \t\n]+ {
        actualizarLocationsColumnas();
        fprintf(stderr, "Error léxico <linea:%d columna:%d> Secuencia no válida: %s (a continuación del caracter no válido)\n", yylloc.first_line, yylloc.first_column, yytext);
        BEGIN(INITIAL);
    }
}

expr: expr '+' expr { $$ = $1 + $3; }
    | expr '*' expr { $$ = $1 * $3; }
    | '(' expr ')'  { $$ = $2; }
    | ENTERO        { $$ = $1; }
    ;
%type <dval> exp
line: expr ';' { printf("El resultado de la expresión es: %d\n", $1); }
    | exp '\n' { printf("El resultado de la expresión es: %g\n", $<dval>1); }
    | declaVarSimples '\n' { printf("Declaración correcta de variable simple: %s\n", $<cadena>1); }
    ;

expr : expr '+' expr { $$ = $1 + $3; 
                      printf("Suma en línea %d, columna %d: %d + %d = %d\n", 
                             @2.first_line, @2.first_column, $1, $3, $$); }

declaVarSimples: TIPO_DATO IDENTIFICADOR ';'  {
    fprintf(stdout, "Declaración correcta de variable simple: %s %s;\n", $<cadena>1, $<cadena>2);
    $<cadena>$ = (char *)malloc(strlen($1) + strlen($2) + 3);
    strcpy($<cadena>$, $<cadena>1);
    strcat($<cadena>$,  " ");
    strcat($<cadena>$, $<cadena>2);
    strcat($<cadena>$,  ";");
}
    | error { errorCount++; yyerrok; }
    ;

exp: NUM                { $<dval>$ = $<dval>1; }
    | ENTERO            { $<dval>$ = $<ival>1; }
    | exp '+' exp       { $<dval>$ = $<dval>1 + $<dval>3; }
    | exp '-' exp       { $<dval>$ = $<dval>1 - $<dval>3; }
    | exp '*' exp       { $<dval>$ = $<dval>1 * $<dval>3; }
    | exp '/' exp       { 
                            if($<dval>3 == 0) {
                                yyerror("No se puede dividir por 0");
                                YYABORT; // return 1;
                            } else {
                                $<dval>$ = $<dval>1 / $<dval>3; 
                            }
                        }
    | '-' exp           { $<dval>$ = -$<dval>2; }
    | '(' exp ')'       { $<dval>$ = $<dval>2; }
    ;

// %type <dval> exp
// expr: expr '+' expr { $$ = $1 + $3; }
//     | expr '*' expr { $$ = $1 * $3; }
//     | '(' expr ')'  { $$ = $2; }
//     | ENTERO        { $$ = $1; }
//     ;

        //para el analizador semantico
        Simbolo* simboloVar = malloc(sizeof(Simbolo));
        simboloVar->ambito = cantidadScopes(tablaGral);
        simboloVar->key = strdup($2);
        simboloVar->tipo = VARIABLE;
        simboloVar->externo = 0;
        simboloVar->calificador = 0;
        simboloVar->especificador = 0;
        simboloVar->tipoDato = convertirTipoDatoEnEnum($1);
        simboloVar->tipoParametros = NULL;

        if(dobleDeclaracionVar(tablaGral, simboloVar->key)) {
            report_error("en delaVarSimples", @$.first_line, "variable redeclarada en scope");
        } else {
            agregarSimboloVar(tablaGral, simboloVar);
        }

        //para el analizador semantico
        Simbolo* simboloVar = malloc(sizeof(Simbolo));
        simboloVar->ambito = cantidadScopes(tablaGral);
        simboloVar->key = strdup($2);
        simboloVar->tipo = VARIABLE;
        simboloVar->externo = 0;
        simboloVar->calificador = 0;
        simboloVar->especificador = 0;
        simboloVar->tipoDato = convertirTipoDatoEnEnum($1);
        simboloVar->tipoParametros = NULL;

        if(dobleDeclaracionVar(tablaGral, simboloVar->key)) {
            report_error("en delaVarSimples", @$.first_line, "variable redeclarada en scope");
        } else {
            agregarSimboloVar(tablaGral, simboloVar);
        }

char* nomVar = obtenerNombre($1);
        if(nomVar != NULL) {
            Simbolo* sVar = buscarSimbolo(tablaGral, obtenerNombre($1), cantidadScopes(tablaGral));
            if(sVar == NULL) {
                report_error("en expresion", @$.first_line, "variable no declarada para asignacion");
            }
            if(!asignacionValor(sVar->tipoDato, $3)) {
                report_error("en expresion", @$.first_line, "asignacion incompatible con tipoDato");
            }
            free(nomVar);
        }

                Simbolo* s = buscarSimbolo(tablaGral, $1);
        if(s == NULL) {
            report_error("en expPrimaria", @$.first_line, "variable no declarada");
        }
        else {
            $$.cadena =
        }


#ifndef TABLA_SIMBOLOS_H
#define TABLA_SIMBOLOS_H

#include "stackModule.h"

typedef enum {
    VARIABLE,
    ENUM,
    FUNCION
} SimboloTipo;

typedef enum {
    INT,
    CHAR,
    DOUBLE,
    FLOAT,
    VOID
} TipoDato;

typedef struct {
    int ambito;                // scope de declaracion
    char* key;                 // id
    SimboloTipo tipo;          // var o funcion
    int externo;               // var externa 1 (true) o 0 (false)
    int calificador;           // var const 1 (true) o 0 (false)
    int especificador;         // var unsigned 1 (true) o 0 (false)
    TipoDato tipoDato;         // tipo_dato
    stack_t* valor_es;         // valor/es guardados en la declaracion
    stack_t* tipoParametros;   // pila del tipo de cada parametro de la funcion
} Simbolo;

typedef struct {
    stack_t* ambitos;   // pila de tablas (cada una es un scope)
} TablaScopes;          // los niveles del 1 al infinito

TablaScopes* initTS();
void destroyTS(TablaScopes* tablaGral);
void agregarScope(TablaScopes* tablaGral);
void agregarSimboloVar(TablaScopes* tablaGral, Simbolo* var);
void agregarSimboloFuncion(TablaScopes* tablaGral, Simbolo* funcion);
// sirve para identidicar una var no declarada
int existeSimbolo(TablaScopes* tablaGral, char* key);   // 1 (existe), 0 (no)
Simbolo* buscarSimbolo(TablaScopes* tablaGral, char* key);
int cantidadSimbolos(TablaScopes* tablaGral, int ambito);
int cantidadScopes(TablaScopes* tablaGral);
// 1 -> hay doble declaracion, 0 -> no
int dobleDeclaracionVar(TablaScopes* tablaGral, char* key);
// control invocacion de funciones
// 1(correcto), 0(no)
int invocacionFuncion(TablaScopes* tablaGral, char* key, stack_t* tipoParametros);
// control asignacion de valor a var
// 1(correcto), 0(no)
int asignacionValor(TipoDato tipoVariable, TipoDato tipoValor);
int convertirTipoDatoEnEnum(char* tipoDato);
char* obtenerNombre(stack_t* expresion);

#endif